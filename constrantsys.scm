; (define C (make-connector))
; (define F (make-connector))
; (celsius-fahrenheit-converter C F)
; (define (celsius-fahrenheit-converter c f)
;   (let(
;       (w (make-connector))
;       (u (make-connector))
;       (v (make-connector))
;       (x (make-connector))
;       (y (make-connector)))
;     (multiplier c w u)
;     (multiplier v x u)
;     (adder v y f)
;     (constant 9 w)
;     (constant 5 x)
;     (constant 32 y)
;   )
; )
(define (adder a1 a2 sum)
    (define (process-new-value)
      (cond ((and (has-value? a1) (has-value? a2))
                  (set-value! sum (+ (get-value a1) (get-value a2)) me))
            ((and (has-value? a1) (has-value? sum))
                  (set-value! a2 (- (get-value sum) (get-value a1)) me))
            ((and (has-value? a2) (has-value? sum))
                  (set-value! a1 (- (get-value sum) (get-value a2)) me))
      )
    )
    (define (process-forget-value)
      (forget-value! sum me)
      (forget-value! a1 me)
      (forget-value! a2 me)
      (process-new-value)
    )
    (define (me request)
      (cond ((eq? request 'I-have-a-value) (process-new-value))
            ((eq? request 'I-lost-my-value) (process-forget-value))
            (else (error "Unknow request: ADDER" request))
        )
    )
    (connect sum me)
    (connect a1 me)
    (connect a2 me)
    me
)

(define (multiplier m1 m2 product)
    (define (process-new-value)
      (cond  ((or (and (has-value? m1) (= (get-value m1) 0))
                  (and (has-value? m2) (= (get-value m2) 0)))
              (set-value! product 0 me))
              ((and (has-value? m1) (has-value? m2))
                (set-value! product (* (get-value m1) (get-value m2)) me))
              ((and (has-value? m1) (has-value? product))
                (set-value! m2 (/ (get-value product) (get-value m1)) me))
              ((and (has-value? m2) (has-value? product))
                (set-value! m1 (/ (get-value product) (get-value m2)) me))
        )
    )
    (define (process-forget-value)
      (forget-value! m1 me)
      (forget-value! m2 me)
      (forget-value! product me)
      (process-new-value)
    )
    (define (me request)
      (cond ((eq? request 'I-have-a-value) (process-new-value))
            ((eq? request 'I-lost-my-value) (process-forget-value))
            (else (error "Unknow request: MULTIPLIER" request))
        )
    )
    (connect m1 me)
    (connect m2 me)
    (connect product me)
    me
)
(define (constant value connector)
    (define (me request)
      (error "Unknown request: CONSTANT" request)
    )
    (connect connector me)
    (set-value! connector value me)
    me
)

(define (probe name connector)
    (define (print-probe value)
      (newline)
      (display "Probe: ")
      (display name)
      (display " = ")
      (display value)
    )
    (define (process-new-value)
      (print-probe (get-value connector))
    )
    (define (process-forget-value)
      (print-probe "?")
    )
    (define (me request)
      (cond ((eq? request 'I-have-a-value) (process-new-value))
            ((eq? request 'I-lost-my-value) (process-forget-value))
            (else (error "Unknow request: PROBE" request))
      )
    )
    (connect connector me)
    me
)
(define (inform-about-value constraint)
    (constraint 'I-have-a-value)
)
(define (inform-about-no-value constraint)
    (constraint 'I-lost-my-value)
)

(define (make-connector)
    (let ((value false) (informant false) (constraints '()))
      (define (set-my-value newval setter)
        (cond ((not (has-value? me))
                (set! value newval)
                (set! informant setter)
                (for-each-except setter inform-about-value constraints)
              )
              ((not (= value newval))
                (error "Contraction" (list value newval))
              )
              (else 'ignored)
        )
      ) ;set-my-value
      (define (forget-my-value retractor)
        (if (eq? retractor informant)
            (begin (set! informant false)
                (for-each-except retractor inform-about-no-value constraints)
            )
            'ignored
        )
      ) ;forget-my-value
      (define (connect new-constraint)
        (if (not (memq new-constraint constraints))
            (set! constraints (cons new-constraint constraints))
        )
        (if (has-value? me)
          (inform-about-value new-constraint)
        )
        'done
      ) ;connect
      (define (me request)
        (cond ((eq? 'has-value? request) (if informant true false))
              ((eq? 'value request) value)
              ((eq? 'set-value! request) set-my-value)
              ((eq? 'forget request) forget-my-value)
              ((eq? 'connect request) connect)
              (else (error "Unknown operation: CONNECTOR"
                request))
        )
      )
      me
    )
) ;make-connector

(define (for-each-except excepter proc items)
	(define (loop items)
		(cond ((null? items) 'done)
			((eq? (car items) excepter) (loop (cdr items)))
			(else (proc (car items))
						(loop (cdr items))
			)
		)
	)
	(loop items)
) ;for-each-except

(define (has-value? connector)
	(connector 'has-value?)
)
(define (get-value connector)
	(connector 'value)
)
(define (set-value! connector new-val informant)
	((connector 'set-value!) new-val informant)
)
(define (forget-value! connector retractor)
   ((connector 'forget) retractor)
)
(define (connect connector new-constraint)
	((connector 'connect) new-constraint)
)